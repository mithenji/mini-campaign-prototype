/**
 * Generated by Verge3D Puzzles v.3.5.0
 * Thu Dec 17 2020 11:11:37 GMT+0800 (中国标准时间)
 * Prefer not editing this file as your changes may get overridden once Puzzles are saved.
 * Check out https://www.soft8soft.com/docs/manual/en/introduction/Using-JavaScript.html
 * for the information on how to add your own JavaScript to Verge3D apps.
 */

"use strict";

(function () {

    // global variables/constants used by puzzles' functions

    var LIST_NONE = "<none>";

    var _pGlob = {};

    _pGlob.objCache = {};
    _pGlob.fadeAnnotations = true;
    _pGlob.objClickInfo = [];
    _pGlob.pickedObject = "";
    _pGlob.objHoverInfo = [];
    _pGlob.hoveredObject = "";
    _pGlob.objMovementInfos = {};
    _pGlob.objDragOverCallbacks = [];
    _pGlob.objDragOverInfoByBlock = {}
    _pGlob.dragMoveOrigins = {};
    _pGlob.dragScaleOrigins = {};
    _pGlob.mediaElements = {};
    _pGlob.loadedFiles = {};
    _pGlob.loadedFile = "";
    _pGlob.promiseValue = "";
    _pGlob.animMixerCallbacks = [];
    _pGlob.arHitPoint = new v3d.Vector3(0, 0, 0);
    _pGlob.states = [];
    _pGlob.percentage = 0;
    _pGlob.animateParamUpdate = null;
    _pGlob.openedFile = "";
    _pGlob.xrSessionAcquired = false;
    _pGlob.xrSessionCallbacks = [];
    _pGlob.screenCoords = new v3d.Vector2();
    _pGlob.gamepadIndex = 0;

    _pGlob.AXIS_X = new v3d.Vector3(1, 0, 0);
    _pGlob.AXIS_Y = new v3d.Vector3(0, 1, 0);
    _pGlob.AXIS_Z = new v3d.Vector3(0, 0, 1);
    _pGlob.MIN_DRAG_SCALE = 10e-4;
    _pGlob.SET_OBJ_ROT_EPS = 1e-8;

    _pGlob.vec2Tmp = new v3d.Vector2();
    _pGlob.vec2Tmp2 = new v3d.Vector2();
    _pGlob.vec3Tmp = new v3d.Vector3();
    _pGlob.vec3Tmp2 = new v3d.Vector3();
    _pGlob.vec3Tmp3 = new v3d.Vector3();
    _pGlob.vec3Tmp4 = new v3d.Vector3();
    _pGlob.eulerTmp = new v3d.Euler();
    _pGlob.eulerTmp2 = new v3d.Euler();
    _pGlob.quatTmp = new v3d.Quaternion();
    _pGlob.quatTmp2 = new v3d.Quaternion();
    _pGlob.colorTmp = new v3d.Color();
    _pGlob.mat4Tmp = new v3d.Matrix4();
    _pGlob.planeTmp = new v3d.Plane();
    _pGlob.raycasterTmp = new v3d.Raycaster();
    _pGlob.intervals = {};

    var _pPhysics = {};

    _pPhysics.tickCallbacks = [];
    _pPhysics.syncList = [];
    _pPhysics.consList = [];

    // internal info
    _pPhysics.collisionData = [];

    // goes to collision callback
    _pPhysics.collisionInfo = {
        objectA: "",
        objectB: "",
        distance: 0,
        positionOnA: [0, 0, 0],
        positionOnB: [0, 0, 0],
        normalOnB: [0, 0, 0]
    };

    var _noWebAudioReported = false;

    var PL = v3d.PL = v3d.PL || {};

    // a more readable alias for PL (stands for "Puzzle Logic")
    v3d.puzzles = PL;

    PL.procedures = PL.procedures || {};

    _pGlob.wooProductInfo = {};


    PL.execInitPuzzles = function (options) {
        // always null, should not be available in "init" puzzles
        var appInstance = null;
        // app is more conventional than appInstance (used in exec script and app templates)
        var app = null;

        var _initGlob = {};
        _initGlob.percentage = 0;
        _initGlob.output = {
            initOptions: {
                fadeAnnotations: true,
                useBkgTransp: false,
                preserveDrawBuf: false,
                useCompAssets: false,
                useFullscreen: true,
                useCustomPreloader: false,
                preloaderStartCb: function () {},
                preloaderProgressCb: function () {},
                preloaderEndCb: function () {},
            }
        }

        // provide the container's id to puzzles that need access to the container
        _initGlob.container = options !== undefined && "container" in options
            ? options.container : "";


        var PROC = {};

        // initSettings puzzle
        _initGlob.output.initOptions.fadeAnnotations = true;
        _initGlob.output.initOptions.useBkgTransp = false;
        _initGlob.output.initOptions.preserveDrawBuf = false;
        _initGlob.output.initOptions.useCompAssets = false;
        _initGlob.output.initOptions.useFullscreen = false;

        return _initGlob.output;
    }

    PL.init = function (appInstance, initOptions) {

        // app is more conventional than appInstance (used in exec script and app templates)
        var app = appInstance;

        initOptions = initOptions || {};

        if("fadeAnnotations" in initOptions) {
            _pGlob.fadeAnnotations = initOptions.fadeAnnotations;
        }

        this.procedures["start_raining"] = start_raining;
        this.procedures["run_rain_process"] = run_rain_process;
        this.procedures["rain_process"] = rain_process;
        this.procedures["hit_pocket"] = hit_pocket;

        var PROC = {
            "start_raining": start_raining,
            "run_rain_process": run_rain_process,
            "rain_process": rain_process,
            "hit_pocket": hit_pocket,
        };

        var playV, time, process_i, list_i, X, Y, r, duration, this_rain, hit, picked, XX, YY, ZZ, max_pocketV, dropsV,
            now_drops, i, rain_list;


        // bloom puzzle
        function bloom(threshold, strength, radius) {
            appInstance.enablePostprocessing([{
                type: "bloom",
                threshold: threshold,
                strength: strength,
                radius: radius
            }]);
        }


        // utility function envoked by almost all V3D-specific puzzles
        // filter off some non-mesh types
        function notIgnoredObj(obj) {
            return (obj.type !== "AmbientLight" && obj.name !== ""
                && !(obj.isMesh && obj.isMaterialGeneratedMesh));
        }


        // utility function envoked by almost all V3D-specific puzzles
        // find first occurence of the object by its name
        function getObjectByName(objName) {
            var objFound;
            var runTime = _pGlob !== undefined;
            objFound = runTime ? _pGlob.objCache[objName] : null;

            if(objFound && objFound.name === objName)
                return objFound;

            appInstance.scene.traverse(function (obj) {
                if(!objFound && notIgnoredObj(obj) && (obj.name == objName)) {
                    objFound = obj;
                    if(runTime) {
                        _pGlob.objCache[objName] = objFound;
                    }
                }
            });
            return objFound;
        }


        // utility function envoked by almost all V3D-specific puzzles
        // retrieve all objects on the scene
        function getAllObjectNames() {
            var objNameList = [];
            appInstance.scene.traverse(function (obj) {
                if(notIgnoredObj(obj))
                    objNameList.push(obj.name)
            });
            return objNameList;
        }


        // utility function envoked by almost all V3D-specific puzzles
        // retrieve all objects which belong to the group
        function getObjectNamesByGroupName(targetGroupName) {
            var objNameList = [];
            appInstance.scene.traverse(function (obj) {
                if(notIgnoredObj(obj)) {
                    var groupNames = obj.groupNames;
                    if(!groupNames)
                        return;
                    for (var i = 0; i < groupNames.length; i++) {
                        var groupName = groupNames[i];
                        if(groupName == targetGroupName) {
                            objNameList.push(obj.name);
                        }
                    }
                }
            });
            return objNameList;
        }


        // utility function envoked by almost all V3D-specific puzzles
        // process object input, which can be either single obj or array of objects, or a group
        function retrieveObjectNames(objNames) {
            var acc = [];
            retrieveObjectNamesAcc(objNames, acc);
            return acc;
        }

        function retrieveObjectNamesAcc(currObjNames, acc) {
            if(typeof currObjNames == "string") {
                acc.push(currObjNames);
            } else if(Array.isArray(currObjNames) && currObjNames[0] == "GROUP") {
                var newObj = getObjectNamesByGroupName(currObjNames[1]);
                for (var i = 0; i < newObj.length; i++)
                    acc.push(newObj[i]);
            } else if(Array.isArray(currObjNames) && currObjNames[0] == "ALL_OBJECTS") {
                var newObj = getAllObjectNames();
                for (var i = 0; i < newObj.length; i++)
                    acc.push(newObj[i]);
            } else if(Array.isArray(currObjNames)) {
                for (var i = 0; i < currObjNames.length; i++)
                    retrieveObjectNamesAcc(currObjNames[i], acc);
            }
        }


        // show and hide puzzles
        function changeVis(objNames, bool) {
            objNames = retrieveObjectNames(objNames);
            if(!objNames)
                return;
            for (var i = 0; i < objNames.length; i++) {
                var objName = objNames[i]
                if(!objName)
                    continue;
                var obj = getObjectByName(objName);
                if(!obj)
                    continue;
                obj.visible = bool;
            }
        }


        // cloneObject puzzle
        function findUniqueObjectName(name) {
            function objNameUsed(name) {
                return Boolean(getObjectByName(name));
            }

            while (objNameUsed(name)) {
                var r = name.match(/^(.*?)(\d+)$/);
                if(!r) {
                    name += "2";
                } else {
                    name = r[1] + (parseInt(r[2], 10) + 1);
                }
            }
            return name;
        }


        // cloneObject puzzle
        function cloneObject(objName) {
            if(!objName)
                return;
            var obj = getObjectByName(objName);
            if(!obj)
                return;
            var newObj = obj.clone();
            newObj.name = findUniqueObjectName(obj.name);
            appInstance.scene.add(newObj);
            return newObj.name;
        }


        // utility function used by the whenClicked, whenHovered and whenDraggedOver puzzles
        function initObjectPicking(callback, eventType, mouseDownUseTouchStart, mouseButtons) {

            var elem = appInstance.renderer.domElement;
            elem.addEventListener(eventType, pickListener);

            if(eventType == "mousedown") {

                var touchEventName = mouseDownUseTouchStart ? "touchstart" : "touchend";
                elem.addEventListener(touchEventName, pickListener);

            } else if(eventType == "dblclick") {

                var prevTapTime = 0;

                function doubleTapCallback(event) {

                    var now = new Date().getTime();
                    var timesince = now - prevTapTime;

                    if(timesince < 600 && timesince > 0) {

                        pickListener(event);
                        prevTapTime = 0;
                        return;

                    }

                    prevTapTime = new Date().getTime();
                }

                var touchEventName = mouseDownUseTouchStart ? "touchstart" : "touchend";
                elem.addEventListener(touchEventName, doubleTapCallback);
            }

            var raycaster = new v3d.Raycaster();

            function pickListener(event) {
                event.preventDefault();

                var xNorm = 0, yNorm = 0;
                if(event instanceof MouseEvent) {
                    if(mouseButtons && mouseButtons.indexOf(event.button) == -1)
                        return;
                    xNorm = event.offsetX / elem.clientWidth;
                    yNorm = event.offsetY / elem.clientHeight;
                } else if(event instanceof TouchEvent) {
                    var rect = elem.getBoundingClientRect();
                    xNorm = (event.changedTouches[0].clientX - rect.left) / rect.width;
                    yNorm = (event.changedTouches[0].clientY - rect.top) / rect.height;
                }

                _pGlob.screenCoords.x = xNorm * 2 - 1;
                _pGlob.screenCoords.y = -yNorm * 2 + 1;
                raycaster.setFromCamera(_pGlob.screenCoords, appInstance.camera);
                var objList = [];
                appInstance.scene.traverse(function (obj) {objList.push(obj);});
                var intersects = raycaster.intersectObjects(objList);
                callback(intersects, event);
            }
        }

        function objectsIncludeObj(objNames, testedObjName) {
            if(!testedObjName) return false;

            for (var i = 0; i < objNames.length; i++) {
                if(testedObjName == objNames[i]) {
                    return true;
                } else {
                    // also check children which are auto-generated for multi-material objects
                    var obj = getObjectByName(objNames[i]);
                    if(obj && obj.type == "Group") {
                        for (var j = 0; j < obj.children.length; j++) {
                            if(testedObjName == obj.children[j].name) {
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        }

        // utility function used by the whenClicked, whenHovered, whenDraggedOver, and raycast puzzles
        function getPickedObjectName(obj) {
            // auto-generated from a multi-material object, use parent name instead
            if(obj.isMesh && obj.isMaterialGeneratedMesh && obj.parent) {
                return obj.parent.name;
            } else {
                return obj.name;
            }
        }


        // whenClicked puzzle
        function registerOnClick(objNames, xRay, doubleClick, mouseButtons, cbDo, cbIfMissedDo) {
            objNames = retrieveObjectNames(objNames) || [];

            var objNamesFiltered = objNames.filter(function (name) {
                return name;
            });

            // for AR/VR
            _pGlob.objClickInfo.push({
                objNames: objNamesFiltered,
                callbacks: [cbDo, cbIfMissedDo]
            });

            initObjectPicking(function (intersects, event) {

                var isPicked = false;

                var maxIntersects = xRay ? intersects.length : Math.min(1, intersects.length);

                for (var i = 0; i < maxIntersects; i++) {
                    var obj = intersects[i].object;
                    var objName = getPickedObjectName(obj);

                    if(objectsIncludeObj(objNamesFiltered, objName)) {
                        // save the object for the pickedObject block
                        _pGlob.pickedObject = objName;
                        isPicked = true;
                        cbDo(event);
                    }

                }

                if(!isPicked) {
                    _pGlob.pickedObject = "";
                    cbIfMissedDo(event);
                }

            }, doubleClick ? "dblclick" : "mousedown", false, mouseButtons);
        }


        /**
         * Get a scene that contains the root of the given action.
         */
        function getSceneByAction(action) {
            var root = action.getRoot();
            var scene = root.type == "Scene" ? root : null;
            root.traverseAncestors(function (ancObj) {
                if(ancObj.type == "Scene") {
                    scene = ancObj;
                }
            });
            return scene;
        }


        /**
         * Get the current scene's framerate.
         */
        function getSceneAnimFrameRate(scene) {
            if(scene && "v3d" in scene.userData && "animFrameRate" in scene.userData.v3d) {
                return scene.userData.v3d.animFrameRate;
            }
            return 24;
        }


        var initAnimationMixer = function () {

            function onMixerFinished(e) {
                var cb = _pGlob.animMixerCallbacks;
                var found = [];
                for (var i = 0; i < cb.length; i++) {
                    if(cb[i][0] == e.action) {
                        cb[i][0] = null; // desactivate
                        found.push(cb[i][1]);
                    }
                }
                for (var i = 0; i < found.length; i++) {
                    found[i]();
                }
            }

            return function initAnimationMixer() {
                if(appInstance.mixer && !appInstance.mixer.hasEventListener("finished", onMixerFinished))
                    appInstance.mixer.addEventListener("finished", onMixerFinished);
            };

        }();


        // animation puzzles
        function operateAnimation(operation, animations, from, to, loop, speed, callback, isPlayAnimCompat, rev) {
            if(!animations)
                return;
            // input can be either single obj or array of objects
            if(typeof animations == "string")
                animations = [animations];

            function processAnimation(animName) {
                var action = v3d.SceneUtils.getAnimationActionByName(appInstance, animName);
                if(!action)
                    return;
                switch (operation) {
                    case "PLAY":
                        if(!action.isRunning()) {
                            action.reset();
                            if(loop && (loop != "AUTO"))
                                action.loop = v3d[loop];
                            var scene = getSceneByAction(action);
                            var frameRate = getSceneAnimFrameRate(scene);

                            // compatibility reasons: deprecated playAnimation puzzles don't
                            // change repetitions
                            if(!isPlayAnimCompat) {
                                action.repetitions = Infinity;
                            }

                            var timeScale = Math.abs(parseFloat(speed));
                            if(rev)
                                timeScale *= -1;

                            action.timeScale = timeScale;
                            action.timeStart = from !== null ? from / frameRate : 0;
                            if(to !== null) {
                                action.getClip().duration = to / frameRate;
                            } else {
                                action.getClip().resetDuration();
                            }
                            action.time = timeScale >= 0 ? action.timeStart : action.getClip().duration;

                            action.paused = false;
                            action.play();

                            // push unique callbacks only
                            var callbacks = _pGlob.animMixerCallbacks;
                            var found = false;

                            for (var j = 0; j < callbacks.length; j++)
                                if(callbacks[j][0] == action && callbacks[j][1] == callback)
                                    found = true;

                            if(!found)
                                _pGlob.animMixerCallbacks.push([action, callback]);
                        }
                        break;
                    case "STOP":
                        action.stop();

                        // remove callbacks
                        var callbacks = _pGlob.animMixerCallbacks;
                        for (var j = 0; j < callbacks.length; j++)
                            if(callbacks[j][0] == action) {
                                callbacks.splice(j, 1);
                                j--
                            }

                        break;
                    case "PAUSE":
                        action.paused = true;
                        break;
                    case "RESUME":
                        action.paused = false;
                        break;
                    case "SET_FRAME":
                        var scene = getSceneByAction(action);
                        var frameRate = getSceneAnimFrameRate(scene);
                        action.time = from ? from / frameRate : 0;
                        action.play();
                        action.paused = true;
                        break;
                }
            }

            for (var i = 0; i < animations.length; i++) {
                var animName = animations[i];
                if(animName)
                    processAnimation(animName);
            }

            initAnimationMixer();
        }


        function start_raining(time) {
            /* 启动下雨的线程 */

            operateAnimation("PLAY", "camera_center", 0, 90, "LoopOnce", 0.5,
                function () {}, undefined, false);

            var i_end = dropsV - 1;
            var i_inc = 1;
            if(0 > i_end) {
                i_inc = -i_inc;
            }
            for (i = 0; i_inc >= 0 ? i <= i_end : i >= i_end; i += i_inc) {
                // 每个线程的序号
                run_rain_process(i);
            }
        }


        // setTimeout puzzle
        function registerSetTimeout(timeout, callback) {
            window.setTimeout(callback, 1000 * timeout);
        }


        // 为首次启动的下雨线程创建启动时间差
        function run_rain_process(process_i) {
            time = process_i * 0.3;
            registerSetTimeout(time, function () {
                console.log(" i=" + String(process_i));
                rain_process(process_i, null, null, null, null, null);
            });
        }

        function mathRandomInt(a, b) {
            if(a > b) {
                // Swap a and b to ensure a is smaller.
                var c = a;
                a = b;
                b = c;
            }
            return Math.floor(Math.random() * (b - a + 1) + a);
        }


        /**
         * Retrieve coordinate system from the loaded scene
         */
        function getCoordSystem() {
            var scene = appInstance.scene;

            if(scene && "v3d" in scene.userData && "coordSystem" in scene.userData.v3d) {
                return scene.userData.v3d.coordSystem;
            } else {
                // COMPAT: <2.17, consider replacing to 'Y_UP_RIGHT' for scenes with unknown origin
                return "Z_UP_RIGHT";
            }
        }


        /**
         * Transform coordinates from one space to another
         * Can be used with Vector3 or Euler.
         */
        function coordsTransform(coords, from, to, noSignChange) {

            if(from == to)
                return coords;

            var y = coords.y, z = coords.z;

            if(from == "Z_UP_RIGHT" && to == "Y_UP_RIGHT") {
                coords.y = z;
                coords.z = noSignChange ? y : -y;
            } else if(from == "Y_UP_RIGHT" && to == "Z_UP_RIGHT") {
                coords.y = noSignChange ? z : -z;
                coords.z = y;
            } else {
                console.error("coordsTransform: Unsupported coordinate space");
            }

            return coords;
        }


        /**
         * Verge3D euler rotation to Blender/Max shortest.
         * 1) Convert from intrinsic rotation (v3d) to extrinsic XYZ (Blender/Max default
         *    order) via reversion: XYZ -> ZYX
         * 2) swizzle ZYX->YZX
         * 3) choose the shortest rotation to resemble Blender's behavior
         */
        var eulerV3DToBlenderShortest = function () {

            var eulerTmp = new v3d.Euler();
            var eulerTmp2 = new v3d.Euler();
            var vec3Tmp = new v3d.Vector3();

            return function (euler, dest) {

                var eulerBlender = eulerTmp.copy(euler).reorder("YZX");
                var eulerBlenderAlt = eulerTmp2.copy(eulerBlender).makeAlternative();

                var len = eulerBlender.toVector3(vec3Tmp).lengthSq();
                var lenAlt = eulerBlenderAlt.toVector3(vec3Tmp).lengthSq();

                dest.copy(len < lenAlt ? eulerBlender : eulerBlenderAlt);
                return coordsTransform(dest, "Y_UP_RIGHT", "Z_UP_RIGHT");
            }

        }();


        function RotationInterface() {
            /**
             * For user manipulations use XYZ extrinsic rotations (which
             * are the same as ZYX intrinsic rotations)
             *     - Blender/Max/Maya use extrinsic rotations in the UI
             *     - XYZ is the default option, but could be set from
             *       some order hint if exported
             */
            this._userRotation = new v3d.Euler(0, 0, 0, "ZYX");
            this._actualRotation = new v3d.Euler();
        }

        Object.assign(RotationInterface, {
            initObject: function (obj) {
                if(obj.userData.v3d.puzzles === undefined) {
                    obj.userData.v3d.puzzles = {}
                }
                if(obj.userData.v3d.puzzles.rotationInterface === undefined) {
                    obj.userData.v3d.puzzles.rotationInterface = new RotationInterface();
                }

                var rotUI = obj.userData.v3d.puzzles.rotationInterface;
                rotUI.updateFromObject(obj);
                return rotUI;
            }
        });

        Object.assign(RotationInterface.prototype, {

            updateFromObject: function (obj) {
                var SYNC_ROT_EPS = 1e-8;

                if(!this._actualRotation.equalsEps(obj.rotation, SYNC_ROT_EPS)) {
                    this._actualRotation.copy(obj.rotation);
                    this._updateUserRotFromActualRot();
                }
            },

            getActualRotation: function (euler) {
                return euler.copy(this._actualRotation);
            },

            setUserRotation: function (euler) {
                // don't copy the order, since it's fixed to ZYX for now
                this._userRotation.set(euler.x, euler.y, euler.z);
                this._updateActualRotFromUserRot();
            },

            getUserRotation: function (euler) {
                return euler.copy(this._userRotation);
            },

            _updateUserRotFromActualRot: function () {
                var order = this._userRotation.order;
                this._userRotation.copy(this._actualRotation).reorder(order);
            },

            _updateActualRotFromUserRot: function () {
                var order = this._actualRotation.order;
                this._actualRotation.copy(this._userRotation).reorder(order);
            }

        });


        // setObjTransform puzzle
        function setObjTransform(objNames, mode, x, y, z, offset) {

            objNames = retrieveObjectNames(objNames);
            if(!objNames) return;

            function setObjProp(obj, prop, val) {
                if(!offset) {
                    obj[mode][prop] = val;
                } else {
                    if(mode != "scale")
                        obj[mode][prop] += val;
                    else
                        obj[mode][prop] *= val;
                }
            }

            var inputsUsed = _pGlob.vec3Tmp.set(Number(x !== ""), Number(y !== ""),
                Number(z !== ""));
            var coords = _pGlob.vec3Tmp2.set(x || 0, y || 0, z || 0);

            if(mode === "rotation") {
                // rotations are specified in degrees
                coords.multiplyScalar(v3d.Math.DEG2RAD);
            }

            var coordSystem = getCoordSystem();

            coordsTransform(inputsUsed, coordSystem, "Y_UP_RIGHT", true);
            coordsTransform(coords, coordSystem, "Y_UP_RIGHT", mode === "scale");

            for (var i = 0; i < objNames.length; i++) {

                var objName = objNames[i];
                if(!objName) continue;

                var obj = getObjectByName(objName);
                if(!obj) continue;

                if(mode === "rotation" && coordSystem == "Z_UP_RIGHT") {
                    // Blender/Max coordinates

                    // need all the rotations for order conversions, especially if some
                    // inputs are not specified
                    var euler = eulerV3DToBlenderShortest(obj.rotation, _pGlob.eulerTmp);
                    coordsTransform(euler, coordSystem, "Y_UP_RIGHT");

                    if(inputsUsed.x) euler.x = offset ? euler.x + coords.x : coords.x;
                    if(inputsUsed.y) euler.y = offset ? euler.y + coords.y : coords.y;
                    if(inputsUsed.z) euler.z = offset ? euler.z + coords.z : coords.z;

                    /**
                     * convert from Blender/Max default XYZ extrinsic order to v3d XYZ
                     * intrinsic with reversion (XYZ -> ZYX) and axes swizzling (ZYX -> YZX)
                     */
                    euler.order = "YZX";
                    euler.reorder(obj.rotation.order);
                    obj.rotation.copy(euler);

                } else if(mode === "rotation" && coordSystem == "Y_UP_RIGHT") {
                    // Maya coordinates

                    // Use separate rotation interface to fix ambiguous rotations for Maya,
                    // might as well do the same for Blender/Max.

                    var rotUI = RotationInterface.initObject(obj);
                    var euler = rotUI.getUserRotation(_pGlob.eulerTmp);
                    // TODO(ivan): this probably needs some reasonable wrapping
                    if(inputsUsed.x) euler.x = offset ? euler.x + coords.x : coords.x;
                    if(inputsUsed.y) euler.y = offset ? euler.y + coords.y : coords.y;
                    if(inputsUsed.z) euler.z = offset ? euler.z + coords.z : coords.z;

                    rotUI.setUserRotation(euler);
                    rotUI.getActualRotation(obj.rotation);
                } else {

                    if(inputsUsed.x) setObjProp(obj, "x", coords.x);
                    if(inputsUsed.y) setObjProp(obj, "y", coords.y);
                    if(inputsUsed.z) setObjProp(obj, "z", coords.z);

                }

                obj.updateMatrixWorld(true);
            }

        }


        // Copyright (c) 2010-2019 Tween.js authors.
        // Easing equations Copyright (c) 2001 Robert Penner http://robertpenner.com/easing/
        // Code copied from https://cdnjs.cloudflare.com/ajax/libs/tween.js/17.3.0/Tween.min.js

        var _Group = function () {this._tweens = {}, this._tweensAddedDuringUpdate = {}};
        _Group.prototype = {
            getAll: function () {return Object.keys(this._tweens).map(function (t) {return this._tweens[t]}.bind(this))},
            removeAll: function () {this._tweens = {}},
            add: function (t) {this._tweens[t.getId()] = t, this._tweensAddedDuringUpdate[t.getId()] = t},
            remove: function (t) {delete this._tweens[t.getId()], delete this._tweensAddedDuringUpdate[t.getId()]},
            update: function (t, n) {
                var e = Object.keys(this._tweens);
                if(0 === e.length) return !1;
                for (t = void 0 !== t ? t : TWEEN.now(); 0 < e.length;) {
                    this._tweensAddedDuringUpdate = {};
                    for (var i = 0; i < e.length; i++) {
                        var r = this._tweens[e[i]];
                        r && !1 === r.update(t) && (r._isPlaying = !1, n || delete this._tweens[e[i]])
                    }
                    e = Object.keys(this._tweensAddedDuringUpdate)
                }
                return !0
            }
        };
        var TWEEN = new _Group;
        TWEEN.Group = _Group, TWEEN._nextId = 0, TWEEN.nextId = function () {return TWEEN._nextId++}, "undefined" == typeof window && "undefined" != typeof process && process.hrtime ? TWEEN.now = function () {
            var t = process.hrtime();
            return 1e3 * t[0] + t[1] / 1e6
        } : "undefined" != typeof window && void 0 !== window.performance && void 0 !== window.performance.now ? TWEEN.now = window.performance.now.bind(window.performance) : void 0 !== Date.now ? TWEEN.now = Date.now : TWEEN.now = function () {return (new Date).getTime()}, TWEEN.Tween = function (t, n) {
            this._object = t, this._valuesStart = {}, this._valuesEnd = {}, this._valuesStartRepeat = {}, this._duration = 1e3, this._repeat = 0, this._repeatDelayTime = void 0, this._yoyo = !1, this._isPlaying = !1, this._reversed = !1, this._delayTime = 0,
                this._startTime = null, this._easingFunction = TWEEN.Easing.Linear.None, this._interpolationFunction = TWEEN.Interpolation.Linear, this._chainedTweens = [], this._onStartCallback = null, this._onStartCallbackFired = !1, this._onUpdateCallback = null, this._onCompleteCallback = null, this._onStopCallback = null, this._group = n || TWEEN, this._id = TWEEN.nextId()
        }, TWEEN.Tween.prototype = {
            getId: function () {return this._id},
            isPlaying: function () {return this._isPlaying},
            to: function (t, n) {return this._valuesEnd = t, void 0 !== n && (this._duration = n), this},
            start: function (t) {
                for (var n in this._group.add(this), this._isPlaying = !0, this._onStartCallbackFired = !1, this._startTime = void 0 !== t ? "string" == typeof t ? TWEEN.now() + parseFloat(t) : t : TWEEN.now(), this._startTime += this._delayTime, this._valuesEnd) {
                    if(this._valuesEnd[n] instanceof Array) {
                        if(0 === this._valuesEnd[n].length) continue;
                        this._valuesEnd[n] = [this._object[n]].concat(this._valuesEnd[n])
                    }
                    void 0 !== this._object[n] && (this._valuesStart[n] = this._object[n], this._valuesStart[n] instanceof Array == !1 && (this._valuesStart[n] *= 1), this._valuesStartRepeat[n] = this._valuesStart[n] || 0)
                }
                return this
            },
            stop: function () {return this._isPlaying && (this._group.remove(this), this._isPlaying = !1, null !== this._onStopCallback && this._onStopCallback(this._object), this.stopChainedTweens()), this},
            end: function () {return this.update(this._startTime + this._duration), this},
            stopChainedTweens: function () {
                for (var t = 0, n = this._chainedTweens.length; t < n;
                     t++) this._chainedTweens[t].stop()
            },
            group: function (t) {return this._group = t, this},
            delay: function (t) {return this._delayTime = t, this},
            repeat: function (t) {return this._repeat = t, this},
            repeatDelay: function (t) {return this._repeatDelayTime = t, this},
            yoyo: function (t) {return this._yoyo = t, this},
            easing: function (t) {return this._easingFunction = t, this},
            interpolation: function (t) {return this._interpolationFunction = t, this},
            chain: function () {return this._chainedTweens = arguments, this},
            onStart: function (t) {return this._onStartCallback = t, this},
            onUpdate: function (t) {return this._onUpdateCallback = t, this},
            onComplete: function (t) {return this._onCompleteCallback = t, this},
            onStop: function (t) {return this._onStopCallback = t, this},
            update: function (t) {
                var n, e, i;
                if(t < this._startTime) return !0;
                for (n in !1 === this._onStartCallbackFired && (null !== this._onStartCallback && this._onStartCallback(this._object), this._onStartCallbackFired = !0), e = (t - this._startTime) / this._duration, e = 0 === this._duration || 1 < e ? 1 : e, i = this._easingFunction(e), this._valuesEnd) if(void 0 !== this._valuesStart[n]) {
                    var r = this._valuesStart[n] || 0, a = this._valuesEnd[n];
                    a instanceof Array ? this._object[n] = this._interpolationFunction(a, i) : ("string" == typeof a && (a = "+" === a.charAt(0) || "-" === a.charAt(0) ? r + parseFloat(a) : parseFloat(a)), "number" == typeof a && (this._object[n] = r + (a - r) * i))
                }
                if(null !== this._onUpdateCallback && this._onUpdateCallback(this._object), 1 !== e) return !0;
                if(0 < this._repeat) {
                    for (n in isFinite(this._repeat) && this._repeat--, this._valuesStartRepeat) {
                        if("string" == typeof this._valuesEnd[n] && (this._valuesStartRepeat[n] = this._valuesStartRepeat[n] + parseFloat(this._valuesEnd[n])), this._yoyo) {
                            var s = this._valuesStartRepeat[n];
                            this._valuesStartRepeat[n] = this._valuesEnd[n], this._valuesEnd[n] = s
                        }
                        this._valuesStart[n] = this._valuesStartRepeat[n]
                    }
                    return this._yoyo && (this._reversed = !this._reversed), void 0 !== this._repeatDelayTime ? this._startTime = t + this._repeatDelayTime : this._startTime = t + this._delayTime, !0
                }
                null !== this._onCompleteCallback && this._onCompleteCallback(this._object);
                for (var o = 0, u = this._chainedTweens.length; o < u; o++) this._chainedTweens[o].start(this._startTime + this._duration);
                return !1
            }
        }, TWEEN.Easing = {
            Linear: {None: function (t) {return t}},
            Quadratic: {
                In: function (t) {return t * t},
                Out: function (t) {return t * (2 - t)},
                InOut: function (t) {return (t *= 2) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1)}
            },
            Cubic: {
                In: function (t) {return t * t * t},
                Out: function (t) {return --t * t * t + 1},
                InOut: function (t) {return (t *= 2) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2)}
            },
            Quartic: {
                In: function (t) {return t * t * t * t},
                Out: function (t) {return 1 - --t * t * t * t},
                InOut: function (t) {return (t *= 2) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2)}
            },
            Quintic: {
                In: function (t) {return t * t * t * t * t},
                Out: function (t) {return --t * t * t * t * t + 1},
                InOut: function (t) {return (t *= 2) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2)}
            },
            Sinusoidal: {
                In: function (t) {return 1 - Math.cos(t * Math.PI / 2)},
                Out: function (t) {return Math.sin(t * Math.PI / 2)},
                InOut: function (t) {return .5 * (1 - Math.cos(Math.PI * t))}
            },
            Exponential: {
                In: function (t) {return 0 === t ? 0 : Math.pow(1024, t - 1)},
                Out: function (t) {return 1 === t ? 1 : 1 - Math.pow(2, -10 * t)},
                InOut: function (t) {return 0 === t ? 0 : 1 === t ? 1 : (t *= 2) < 1 ? .5 * Math.pow(1024, t - 1) : .5 * (2 - Math.pow(2, -10 * (t - 1)))}
            },
            Circular: {
                In: function (t) {return 1 - Math.sqrt(1 - t * t)},
                Out: function (t) {return Math.sqrt(1 - --t * t)},
                InOut: function (t) {return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1)}
            },
            Elastic: {
                In: function (t) {return 0 === t ? 0 : 1 === t ? 1 : -Math.pow(2, 10 * (t - 1)) * Math.sin(5 * (t - 1.1) * Math.PI)},
                Out: function (t) {return 0 === t ? 0 : 1 === t ? 1 : Math.pow(2, -10 * t) * Math.sin(5 * (t - .1) * Math.PI) + 1},
                InOut: function (t) {return 0 === t ? 0 : 1 === t ? 1 : (t *= 2) < 1 ? -.5 * Math.pow(2, 10 * (t - 1)) * Math.sin(5 * (t - 1.1) * Math.PI) : .5 * Math.pow(2, -10 * (t - 1)) * Math.sin(5 * (t - 1.1) * Math.PI) + 1}
            },
            Back: {
                In: function (t) {return t * t * (2.70158 * t - 1.70158)},
                Out: function (t) {return --t * t * (2.70158 * t + 1.70158) + 1},
                InOut: function (t) {
                    var n = 2.5949095;
                    return (t *= 2) < 1 ? t * t * ((n + 1) * t - n) * .5 : .5 * ((t -= 2) * t * ((n + 1) * t + n) + 2)
                }
            },
            Bounce: {
                In: function (t) {return 1 - TWEEN.Easing.Bounce.Out(1 - t)},
                Out: function (t) {return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375},
                InOut: function (t) {return t < .5 ? .5 * TWEEN.Easing.Bounce.In(2 * t) : .5 * TWEEN.Easing.Bounce.Out(2 * t - 1) + .5}
            }
        }, TWEEN.Interpolation = {
            Linear: function (t, n) {
                var e = t.length - 1, i = e * n, r = Math.floor(i), a = TWEEN.Interpolation.Utils.Linear;
                return n < 0 ? a(t[0], t[1], i) : 1 < n ? a(t[e], t[e - 1], e - i) : a(t[r], t[e < r + 1 ? e : r + 1], i - r)
            },
            Bezier: function (t, n) {
                for (var e = 0, i = t.length - 1, r = Math.pow, a = TWEEN.Interpolation.Utils.Bernstein, s = 0; s <= i; s++) e += r(1 - n, i - s) * r(n, s) * t[s] * a(i, s);
                return e
            },
            CatmullRom: function (t, n) {
                var e = t.length - 1, i = e * n, r = Math.floor(i), a = TWEEN.Interpolation.Utils.CatmullRom;
                return t[0] === t[e] ? (n < 0 && (r = Math.floor(i = e * (1 + n))), a(t[(r - 1 + e) % e], t[r], t[(r + 1) % e], t[(r + 2) % e], i - r)) : n < 0 ? t[0] - (a(t[0], t[0], t[1], t[1], -i) - t[0]) : 1 < n ? t[e] - (a(t[e], t[e], t[e - 1], t[e - 1], i - e) - t[e]) : a(t[r ? r - 1 : 0], t[r], t[e < r + 1 ? e : r + 1], t[e < r + 2 ? e : r + 2], i - r)
            },
            Utils: {
                Linear: function (t, n, e) {return (n - t) * e + t},
                Bernstein: function (t, n) {
                    var e = TWEEN.Interpolation.Utils.Factorial;
                    return e(t) / e(n) / e(t - n)
                },
                Factorial: function () {
                    var i = [1];
                    return function (t) {
                        var n = 1;
                        if(i[t]) return i[t];
                        for (var e = t; 1 < e; e--) n *= e;
                        return i[t] = n
                    }
                }(),
                CatmullRom: function (t, n, e, i, r) {
                    var a = .5 * (e - t), s = .5 * (i - n), o = r * r;
                    return (2 * n - 2 * e + a + s) * (r * o) + (-3 * n + 3 * e - 2 * a - s) * o + a * r + n
                }
            }
        }, function (t) {"function" == typeof define && define.amd ? define([], function () {return TWEEN}) : "undefined" != typeof module && "object" == typeof exports ? module.exports = TWEEN : void 0 !== t && (t.TWEEN = TWEEN)}(this);


        // animateParam puzzle
        appInstance.renderCallbacks.push(function () { TWEEN.update(); });


        // animateParam puzzle
        function animateParam(from, to, duration, easing, easing2, repeat, yoyo, on_update, when_finished) {

            var mode = easing == "Linear" ?
                TWEEN.Easing.Linear.None : TWEEN.Easing[easing][easing2];

            var tweenObject = (typeof from != "number");

            if(!tweenObject) { // number
                from = [from];
                to = [to];
            }

            var tween = new TWEEN.Tween(from)
                .to(to, duration * 1000)
                .easing(mode)
                .repeat(repeat)
                .yoyo(yoyo)
                .onUpdate(function (object) {
                    if(tweenObject)
                        _pGlob.animateParamUpdate = object;
                    else // number
                        _pGlob.animateParamUpdate = object[0];
                    on_update();
                })
                .onComplete(function (object) {
                    when_finished();
                })
                .start();
        }


        function rain_process(list_i, X, Y, r, duration, this_rain) {
            /* 每个下雨红包的落下动画线程, 落下自动重复 */
            this_rain = rain_list[list_i];
            console.log("this process is " + String(this_rain));
            X = mathRandomInt(-7, 7);
            Y = mathRandomInt(-7, 7);
            r = mathRandomInt(0, 359);
            duration = Math.random() + 6;
            setObjTransform(this_rain, "position", X, Y, 18, false);
            setObjTransform(this_rain, "rotation", "", "", r, false);
            // 红包落下的总计数器
            now_drops = now_drops + 1;
            // 当红包落下次数达到上限停止线程
            //
            if(now_drops < max_pocketV) {
                changeVis(this_rain, true);

                animateParam(22, -18, duration, "Linear", "Out", 0, false,
                    function () {
                        setObjTransform(this_rain, "position", X - _pGlob.animateParamUpdate * 0.1, Y - _pGlob.animateParamUpdate * 0.1, _pGlob.animateParamUpdate, false);
                        setObjTransform(this_rain, "rotation", "", "", r + _pGlob.animateParamUpdate * 10, false);
                    },
                    function () {
                        changeVis(this_rain, false);
                        rain_process(list_i, null, null, null, null, null);
                        console.log(now_drops);
                    });

            }
        }


        // getObjTransform puzzle
        function getObjTransform(objName, mode, coord) {
            if(!objName)
                return;
            var obj = getObjectByName(objName);
            if(!obj)
                return;

            var coordSystem = getCoordSystem();

            var transformVal;

            if(mode === "rotation" && coordSystem == "Z_UP_RIGHT") {
                transformVal = eulerV3DToBlenderShortest(obj.rotation,
                    _pGlob.eulerTmp);
            } else if(mode === "rotation" && coordSystem == "Y_UP_RIGHT") {
                // Maya coordinates
                // Use separate rotation interface to fix ambiguous rotations for Maya,
                // might as well do the same for Blender/Max.

                var rotUI = RotationInterface.initObject(obj);
                transformVal = rotUI.getUserRotation(_pGlob.eulerTmp);
            } else {
                transformVal = coordsTransform(obj[mode].clone(), "Y_UP_RIGHT",
                    coordSystem, mode === "scale");
            }

            if(mode === "rotation") {
                transformVal.x = v3d.MathUtils.radToDeg(transformVal.x);
                transformVal.y = v3d.MathUtils.radToDeg(transformVal.y);
                transformVal.z = v3d.MathUtils.radToDeg(transformVal.z);
            }

            if(coord == "xyz") {
                // remove order component for Euler vectors
                return transformVal.toArray().slice(0, 3);
            } else {
                return transformVal[coord];
            }
        }


        // removeObject puzzles
        function removeObject(objNames) {
            objNames = retrieveObjectNames(objNames);
            if(!objNames)
                return;
            for (var i = 0; i < objNames.length; i++) {
                var objName = objNames[i]
                if(!objName)
                    continue;
                var obj = getObjectByName(objName);
                if(!obj || !obj.parent)
                    continue;

                obj.parent.remove(obj);

                // clean object cache
                _pGlob.objCache = {};
            }
        }


        // Describe this function...
        function hit_pocket(hit, picked, XX, YY, ZZ) {
            hit = cloneObject("red_pocket_groud");
            changeVis(hit, true);
            XX = getObjTransform(picked, "position", "x");
            YY = getObjTransform(picked, "position", "y");
            ZZ = getObjTransform(picked, "position", "z");
            removeObject(picked);

            animateParam(0, 10, 0.5, "Quadratic", "Out", 0, false,
                function () {
                    setObjTransform(hit, "position", XX, YY, ZZ + _pGlob.animateParamUpdate * 0.5, false);
                    setObjTransform(hit, "rotation", "", "", 64 * _pGlob.animateParamUpdate, false);
                    setObjTransform(hit, "scale", (10 - _pGlob.animateParamUpdate) * 0.2, (10 - _pGlob.animateParamUpdate) * 0.2, (10 - _pGlob.animateParamUpdate) * 0.2, false);
                },
                function () {
                    removeObject(hit);
                });

        }


        bloom(0.7, 0.2, 0.1);

        playV = eval("try { eval('play') } catch(e) { }");
        max_pocketV = eval("try { eval('max_pocket') } catch(e) { }");
        dropsV = eval("try { eval('drops') } catch(e) { }");
        now_drops = 0;

        // 点击开始下雨
        //
        registerOnClick("Plane", false, false, [0, 1, 2], function () {
            console.log("gamestart");
            changeVis("red_pocket_groud", false);
            changeVis("Plane", false);
            rain_list = [];
            // 根据 dropsV 参数决定同时运行多少下雨线程, 并创建下雨红包的实体
            for (var count = 0; count < dropsV; count++) {
                rain_list.splice(dropsV, 0, cloneObject("red_pocket_groud"));
            }
            console.log(rain_list);
            start_raining(null);
            // 红包实体创建完后, 添加绑定时间
            registerOnClick(["ALL_OBJECTS"], true, false, [0, 1, 2], function () {
                console.log("点击");
                hit_pocket(null, _pGlob.pickedObject, null, null, null);
            }, function () {});
        }, function () {});


    } // end of PL.init function

})(); // end of closure

/* ================================ end of code ============================= */
